{
  "translation": {
    "project": {
      "title": "팀 프로젝트 2: WORK OUT 상세 구현 과정",
      "description": "이 문서는 WORK OUT 프로젝트를 개발하며 적용했던 기술적인 결정들과 주요 기능들의 구현 방식을 상세히 설명합니다.",
      "architecture": {
        "title": "1. 프로젝트 구조 설계 (아키텍처)",
        "description": "프로젝트의 유지보수성과 확장성을 고려하여 명확한 역할 분담에 중점을 둔 아키텍처를 설계하였습니다.",
        "layers": {
          "controller": "계층 구조",
          "controller.description": "웹 요청을 받는 `Controller`, 핵심 비즈니스 로직을 처리하는 `Service`, 데이터베이스 접근을 담당하는 `Repository`로 역할을 명확히 나누는 `3-Tier 아키텍처`를 기본 구조로 삼았습니다. 이를 통해 각 부분의 책임이 분명해지고 코드 변경 시 다른 부분에 미치는 영향을 최소화할 수 있습니다.",
          "service": "Service 계층",
          "service.description": "`Service` 계층은 `Controller`로부터 요청을 받아 핵심 비즈니스 로직을 수행하고 `Repository`와 상호작용합니다. 트랜잭션 관리 및 복잡한 데이터 처리 등을 담당하여 애플리케이션의 핵심 기능을 구현합니다.",
          "repository": "`Repository` 계층",
          "repository.description": "`Repository` 계층은 데이터베이스와의 직접적인 상호작용을 담당합니다. `JPA`를 활용하여 데이터 조회, 저장, 수정, 삭제 등의 작업을 수행하며, 서비스 계층에 추상화된 데이터 접근 인터페이스를 제공합니다."
        },
        "diagram": "아키텍처 구성도",
        "diagram.description": "`3-Tier Architecture`: `Controller` - `Service` - `Repository`\n`Entity`는 `BaseEntity`를 상속, `DTO`는 계층 간 데이터 전달에 사용"
      },
      "dataModeling": {
        "title": "2. 데이터 모델링",
        "description": "서비스의 핵심 기능을 중심으로 데이터베이스 스키마를 설계하였습니다.",
        "entityOverview": "주요 엔티티 및 관계 개요",
        "relationship": "관계 설계",
        "relationship.description": "관계(예: 게시글 하나에 여러 이미지/댓글 연결), 다대일(N:1) 관계(여러 게시글이 한 명의 작성자 참조) 등 실제 서비스 흐름에 맞게 설계하였습니다.",
        "inheritance": "상속 활용",
        "baseEntity": "`BaseEntity`",
        "inheritance.description": "상속을 통해 생성일시, 수정일시 등 공통 필드를 효율적으로 관리하여 코드 중복을 줄였습니다.",
        "otherCommonFields": "생성일시와 수정일시 외에도 필요에 따라 삭제 여부, 상태 코드 등 다른 공통 필드를 추가할 수 있습니다.",
        "otherFields": "엔티티 간 관계나 핵심 속성 외에도 태그, 카테고리, 좋아요 등 비즈니스 요구사항에 따라 필요한 필드를 추가할 수 있습니다.",
        "mappedSuperclass": "JPA에서 상속 관계 매핑을 위한 부모 클래스로 사용합니다. 실제 테이블로는 생성되지 않고 자식 엔티티 클래스에 매핑 정보만 제공합니다.",
        "entityListeners": "엔티티의 생명주기 이벤트를 감지하여 콜백 메서드를 호출하는 리스너를 지정합니다. AuditingEntityListener는 생성일시, 수정일시를 자동으로 관리합니다.",
        "createdDate": "엔티티가 생성될 때 현재 시간을 자동으로 저장하는 필드를 표시합니다. Spring Data JPA Auditing 기능을 사용합니다.",
        "lastModifiedDate": "엔티티가 수정될 때 현재 시간으로 자동 업데이트되는 필드를 표시합니다. Spring Data JPA Auditing 기능을 사용합니다.",
        "entity": "이 클래스가 JPA 엔티티임을 나타내며, 연결된 데이터베이스 테이블과 매핑됩니다.",
        "id": "엔티티의 기본 키(Primary Key)를 표시합니다.",
        "generatedValue": "기본 키 값을 자동 생성하는 전략을 지정합니다. 기본값은 AUTO로, 데이터베이스에 따라 적절한 전략을 선택합니다.",
        "manyToOne": "다대일(N:1) 관계를 설정합니다. 여러 엔티티가 하나의 엔티티를 참조할 때 사용합니다.",
        "oneToMany": "일대다(1:N) 관계를 설정합니다. 하나의 엔티티가 여러 엔티티를 참조할 때 사용합니다.",
        "mappedBy": "양방향 관계에서 연관관계의 주인이 아닌 쪽에서 주인을 지정합니다. 여기서는 Board 엔티티의 board 필드가 연관관계의 주인입니다."
      },
      "realTimeVideo": {
        "title": "3.1 실시간 화상 통화 시스템 (WebRTC & WebSocket)",
        "goal": "목표",
        "feature1": "트레이너와 회원이 온라인에서 실시간으로 운동 자세를 확인하고 피드백을 주고받을 수 있는 환경을 제공합니다.",
        "feature2": "1:1 PT뿐만 아니라 여러 명이 참여하는 1:N 운동 세션도 지원합니다.",
        "implementation": "구현 방식",
        "implementation.step1": "`WebRTC` 기술을 기반으로 브라우저 간 실시간 오디오 및 비디오 데이터의 `P2P` 직접 전송 기능을 구현하였습니다.",
        "implementation.step2": "이 과정에서 필요한 연결 정보 교환, 즉 시그널링은 `WebSocket`과 `STOMP` 프로토콜을 활용하여 처리하였습니다.",
        "implementation.step3": "프론트엔드 측면에서는 `roomList.html`, `roomCreate.html`, `room.html` 등의 페이지에서 `videoCall.js` 파일을 통해 `WebRTC` 및 `WebSocket` 관련 로직을 담당하도록 하였으며, 백엔드는 `Spring Boot` 프레임워크를 기반으로 `WebSocketConfig`, `Controller`, `Service`, 그리고 데이터베이스 연동 구조로 설계하여 전체 시스템을 안정적으로 지원하도록 구축하였습니다.",
        "issues": "문제점",
        "issues.issue1": "이러한 기능을 구현하는 과정에서 몇 가지 기술적인 문제점에 직면하였습니다.",
        "issues.issue2": "우선, `WebRTC`와 `WebSocket` 프로토콜 모두 브라우저의 동일 출처 정책(`SOP`) 및 `CORS`(`Cross-Origin Resource Sharing`) 정책에 민감하게 반응하여, 특정 보안 헤더(예: `CSRF` 토큰 관련 설정)로 인해 연결이 예기치 않게 차단되는 상황이 발생하였습니다.",
        "issues.issue3": "또한, 보안상의 이유로 `getUserMedia`와 같이 사용자의 미디어 장치에 접근하는 `WebRTC` `API`는 `HTTPS` 환경에서만 정상적으로 작동하므로, 개발 및 테스트 단계에서부터 `HTTPS` 환경 구축이 필수적이었습니다.",
        "solutions": "해결",
        "solutions.solution1": "이러한 문제점들을 해결하기 위해 다음과 같은 접근 방식을 적용하였습니다.",
        "solutions.solution2": "첫째, 브라우저 연결 차단 문제를 해소하고자 백엔드의 `Spring Security` 설정에서 `CORS` 관련하여 허용할 출처(`Origin`), `HTTP` 메서드, 그리고 헤더를 명시적으로 지정하였고, 이와 함께 `SockJS` 라이브러리의 관련 옵션을 세밀하게 조정하여 `WebSocket` 연결 시 발생 가능했던 헤더 관련 이슈를 추가로 해결하였습니다.",
        "solutions.solution3": "둘째, `WebRTC` `API` 호환성 확보 및 전송 데이터 보안 강화를 위해 개발 환경과 실제 서비스 배포 환경 모두에 `HTTPS` 프로토콜을 의무적으로 적용하였습니다.",
        "frontendLogic": "프론트엔드 주요 로직 예시 (`videoCall.js`)",
        "frontendLogic.description": "다음은 `WebRTC` 연결 설정, 시그널링 메시지 처리, 비디오 스트림 관리 등 핵심 로직을 담은 프론트엔드 `JavaScript` 코드의 일부입니다.",
        "demoImage": "그림 1: `WebRTC` 기반 실시간 화상 트레이닝 데모 이미지(예시)",
        "startDemo": "`WebRTC` 데모 시연 시작",
        "endDemo": "데모 종료"
      },
      "boardSystem": {
        "title": "3.2 게시판 시스템 (자유게시판 & 운동 게시판)",
        "goal": "목표",
        "description": "본 시스템의 목표는 사용자 여러분이 자유롭게 글을 쓰고 다양한 정보를 공유할 수 있는 커뮤니티 공간(자유게시판, 운동 게시판)을 제공하는 데 있습니다.",
        "implementation": "구현 방식",
        "implementation.step1": "이를 구현하기 위해 `Spring MVC` 패턴(`Controller`-`Service`-`Repository` 계층 구조)을 기반으로 기본적인 게시글 `CRUD`(생성, 조회, 수정, 삭제) 기능은 물론, 파일 업로드, 댓글 관리, 그리고 페이징 및 검색 기능까지 개발하였습니다.",
        "implementation.step2": "특히, 다양한 조건에 따른 동적 쿼리 생성과 효율적인 페이징 처리를 지원하고자 `QueryDSL` 라이브러리를 도입하여 활용하였습니다.",
        "potentialIssues": "잠재적 문제점",
        "issue1": "하지만 구현 과정에서 향후 발생할 수 있는 잠재적인 문제점들을 고려하였습니다.",
        "issue2": "예를 들어, 게시판에 데이터가 대량으로 축적될 경우 조회 성능이 저하될 수 있는 가능성과, 사용자의 검색 조건이 복잡해질수록 실행되는 데이터베이스 쿼리의 최적화가 필요하다는 점이었습니다.",
        "solutions": "해결 방안",
        "solution1": "이러한 잠재적 이슈에 선제적으로 대응하고 시스템 성능을 확보하기 위해 다음과 같은 해결 방안을 적용하였습니다.",
        "solution2": "첫째, `QueryDSL`을 적극적으로 활용하여 복잡하고 다양한 검색 조건에 대해서도 최적화된 동적 쿼리가 생성되도록 구현함으로써 검색 성능을 개선하였습니다.",
        "carousel": {
          "boardList": "그림 1: 게시판 목록 및 페이징",
          "boardView": "그림 2: 게시글 조회",
          "boardWrite": "그림 3: 게시글 작성 및 파일 첨부",
          "boardSearch": "그림 4: 게시판 검색 기능"
        }
      },
      "queryDsl": {
        "title": "QueryDSL 사용 패턴 요약: 동적/복합 조건 처리",
        "description": "게시판 시스템의 복잡한 검색 기능을 효율적으로 구현하기 위해 QueryDSL의 JPQLQuery와 BooleanBuilder를 조합하여 사용하는 방식을 채택하였습니다.",
        "additionalDescription": "특히, 다양한 조건에 따른 동적 쿼리 생성과 효율적인 페이징 처리를 지원하고자 QueryDSL 라이브러리를 도입하여 활용하였습니다.",
        "codeExample1": "코드 예시 1: JPQLQuery 기반 기본 쿼리 및 조건 추가",
        "codeExample2": "코드 예시 2: BooleanBuilder를 이용한 동적 조건 생성 및 적용",
        "introduction": "우선, 기본적인 쿼리 구조는 JPQLQuery 객체를 기반으로 작성하였습니다. from() 메서드를 사용하여 쿼리의 주 대상을 지정하고, 필요한 데이터가 있을 경우 leftJoin() 등의 메서드를 이용해 연관된 엔티티를 조인하였습니다. 검색 키워드 입력과 같이 비교적 단순하거나 고정적인 기본 조건들은 JPQLQuery의 where() 절에 직접 추가하였습니다.",
        "booleanBuilder": "하지만 사용자의 검색 타입 선택（제목으로 검색, 내용으로 검색, 저자로 검색 등）이나 여러 필터 조건의 조합 등, 요청에 따라 동적으로 변경해야 하는 복잡한 조건은, BooleanBuilder를 사용하여 구성했습니다. BooleanBuilder는, 비즈니스 로직에 따라 개별 조건（Predicate）을 and 또는 or 메서드로 유연하게 연결하여, 최종적인 복합 조건을 동적으로 생성하는 역할을 했습니다. BooleanBuilder를 통해 생성된 이들 동적 조건은, 최종적으로 JPQLQuery 객체의 where() 구문에 통합되어, 실행 시점에 최적화된 완성 형태의 쿼리가 데이터베이스로 전송되도록 구현했습니다."
      },
      "memberManagement": {
        "title": "3.3 회원 관리 시스템 (Member)",
        "goal": "목표",
        "feature1": "안전하고 편리한 회원 인증, 인가, 정보 수정, 권한 관리 기능을 제공합니다.",
        "feature2": "사용자 경험을 최우선으로 고려한 UI/UX를 구현합니다.",
        "implementation": "구현 방식",
        "implementation.step1": "Spring Security를 기반으로 인증 및 인가 기능을 구현하였으며, CustomUserDetailsService를 통해 사용자 정보를 로드하고 BCrypt 알고리즘으로 비밀번호를 암호화하여 관리합니다. 또한, 역할(Role)에 따른 세분화된 권한 관리 기능을 적용하였습니다.",
        "implementation.step2": "추가적으로 아이디 중복 체크 기능과 회원 정보 수정 시 필요한 필드만 선택적으로 업데이트하는 기능을 구현하였습니다.",
        "issues": "문제점",
        "issue1": "구현 과정에서 세션(Session) 관리, CSRF(Cross-Site Request Forgery) 공격 등과 같은 일반적인 웹 보안 취약점에 대한 대응책 마련이 필요하였습니다.",
        "issue2": "또한, 회원이 자신의 정보를 변경할 때 데이터의 일관성과 정확성, 즉 데이터 무결성을 유지하는 것이 중요한 과제였습니다.",
        "solutions": "해결",
        "solution1": "Spring Security가 제공하는 내장 기능을 활용하여 세션 관리 정책, 쿠키(Cookie) 설정, CSRF 방어, CORS(Cross-Origin Resource Sharing) 정책 등을 적절히 구성하여 시스템 보안 수준을 높였습니다.",
        "solution2": "데이터 무결성 확보를 위해, 클라이언트로부터 데이터를 받을 때 DTO(Data Transfer Object) 패턴을 사용하고, 서버 단에서 데이터 유효성 검사(Validation) 로직을 적용하여 잘못된 데이터가 시스템에 입력되는 것을 방지하였습니다.",
        "security": "보안 및 데이터 무결성 구현 상세",
        "sessionManagement": "1. 세션(Session) 관리",
        "sessionManagement.step1": "로그인 성공 시 HttpSession에 회원 정보를 저장하고, 로그아웃 시 세션을 무효화하는 방식으로 사용자 인증 상태를 관리하였습니다.",
        "sessionManagement.step2": "세션 고정 공격 방지를 위해 인증 성공 시 세션 ID를 자동으로 변경하는 설정을 적용하였습니다.",
        "sessionManagement.step3": "한 계정당 동시 세션 수를 제한하여 다중 로그인으로 인한 보안 위험을 줄이도록 하였습니다.",
        "csrf": "2. CSRF(Cross-Site Request Forgery) 대응",
        "csrf.step1": "Spring Security의 CSRF 방어 기능을 활성화하여 모든 상태 변경 요청(POST, PUT, DELETE 등)에 CSRF 토큰 검증을 적용하였습니다.",
        "csrf.step2": "로그인이나 회원가입 등 특정 경로만 CSRF 검증에서 예외로 처리하였습니다.",
        "csrf.step3": "모든 HTML 폼과 AJAX 요청에 CSRF 토큰을 포함하도록 구현하였습니다.",
        "dataConsistency": "3. 회원 정보 변경 시 데이터 무결성",
        "dataConsistency.step1": "회원 정보 수정 시 변경된 필드만 선택적으로 업데이트하는 방식을 적용하여 불필요한 데이터 변경이나 손실을 방지하였습니다.",
        "dataConsistency.step2": "도메인 객체 내부에 각 필드별 변경 메서드를 정의하여 일관된 방식으로 데이터를 변경할 수 있도록 하였습니다.",
        "dataConsistency.step3": "Bean Validation 어노테이션을 사용하여 DTO 단계에서부터 데이터 유효성을 검증하였습니다.",
        "otherSecurity": "4. 기타 보안 설정",
        "otherSecurity.step1": "HTTP 응답 헤더에 보안 관련 헤더를 추가하여 XSS(Cross-Site Scripting), 클릭재킹(Clickjacking) 등의 공격을 방지하였습니다.",
        "otherSecurity.step2": "모든 쿠키에 HttpOnly, SameSite 속성을 적용하여 쿠키 탈취나 악의적인 사용을 어렵게 하였습니다.",
        "otherSecurity.step3": "회원 탈퇴와 같은 민감한 작업에는 @PreAuthorize를 통한 권한 검증을 추가하여 본인만 실행할 수 있도록 제한하였습니다.",
        "mainScreen": "회원 관리 주요 화면",
        "mainScreen.description": "회원 관리 시스템의 주요 화면들로, 로그인 화면부터 마이페이지, 회원정보 수정 등을 확인할 수 있습니다.",
        "mainScreen.carousel": {
          "login": "그림 1: 로그인 화면 - Spring Security 기반 인증 처리",
          "join": "그림 2: 회원가입 화면 - 유효성 검증 및 중복 체크",
          "mypage": "그림 3: 마이페이지 - 회원정보 확인 및 관리"
        },
        "comments": {
          "security.comment1": "세션 만료 시 리디렉션될 URL을 '/member/login?expired'로 설정합니다.",
          "security.comment2": "CSRF 보호를 특정 경로들('/member/login', '/member/join' 등)에 대해 비활성화합니다.",
          "security.comment3": "회원 정보 수정을 위한 서비스 메서드입니다."
        },
        "findExistingMember": "기존 회원 정보 조회 (없으면 예외 발생)",
        "passwordEncryption": "비밀번호 변경 시 암호화 처리",
        "selectiveUpdate": "변경된 필드만 선택적으로 업데이트",
        "otherFieldsUpdate": "기타 필드 업데이트",
        "transactionSave": "트랜잭션 내에서 저장",
        "enableMethodSecurity": "최신 버전에서는 @EnableMethodSecurity 사용",
        "pathAccessControl": "필요시 경로별 접근 제어 추가",
        "exceptionHandlers": "필요시 접근 거부/인증 실패 핸들러 추가"
      },
      "qnaSystem": {
        "title": "3.4 Q&A 시스템",
        "description": "Q&A 시스템은 사용자가 운동 기술, 트레이닝 프로그램 및 기타 피트니스 관련 주제에 대한 질문을 하고 답변을 받을 수 있는 플랫폼을 제공합니다.",
        "additionalDescription": "트레이너와 회원 간의 지식 공유를 촉진하고 시간이 지남에 따라 가치 있는 지식 베이스를 구축하도록 이 시스템을 설계했습니다.",
        "userRequirement": "사용자들은 운동 관련 고민을 더 잘 설명하기 위해 이미지와 함께 질문을 게시할 수 있는 직관적인 인터페이스를 원했습니다.",
        "implementation": "모든 CRUD 기능, 파일 업로드 기능 및 데스크톱과 모바일 장치 모두에서 잘 작동하는 반응형 디자인으로 Q&A 시스템을 구현했습니다.",
        "fileUploadTitle": "파일 업로드 구현",
        "fileUpload": {
          "controller": "파일 업로드 컨트롤러 구현",
          "description": "질문당 여러 이미지 첨부를 지원하는 파일 업로드를 위한 멀티파트 폼 데이터를 처리하는 컨트롤러를 구현했습니다.",
          "step1": "Spring의 MultipartFile API를 사용하여 업로드된 파일을, 저장하기 전에 파일 유형과 크기를 검증하며 처리했습니다.",
          "step2": "이름 충돌을 방지하고 안정적인 검색을 보장하기 위해 각 업로드된 파일에 고유 식별자를 부여했습니다.",
          "step3": "컨트롤러는 데이터베이스 관계를 통해 업로드된 파일을 해당 질문 엔티티와 연결합니다."
        },
        "fileStorageTitle": "파일 저장 구현",
        "fileStorage": {
          "description": "파일 저장을 위해 서버에 파일의 물리적 저장을 관리하는 서비스 계층을 구현했습니다.",
          "step1": "파일은 애플리케이션 속성에 지정된 구성 가능한 디렉터리에 저장됩니다.",
          "step2": "고유성을 보장하고 경로 순회 공격을 방지하기 위해 UUID 기반 이름 지정을 사용합니다.",
          "step3": "각 파일의 메타데이터(원본 이름, 크기, 콘텐츠 유형)는 쉬운 검색 및 관리를 위해 데이터베이스에 저장됩니다."
        },
        "fileAccessTitle": "파일 접근 구현",
        "fileAccess": {
          "description": "업로드된 파일에 대한 안전한 액세스를 제공하기 위해 파일 검색을 위한 전용 엔드포인트를 구현했습니다.",
          "step1": "파일은 직접적인 파일 경로가 아닌 고유 ID로 액세스되어 보안 계층이 추가됩니다.",
          "step2": "시스템은 확장자에 따라 각 파일에 대한 적절한 콘텐츠 유형을 동적으로 결정합니다.",
          "step3": "액세스 제어는 필요한 경우(예: 비공개 질문의 경우) 권한이 있는 사용자만 특정 파일에 액세스할 수 있도록 합니다.",
          "getImageResource": "서비스 호출하여 이미지 리소스 가져오기",
          "determineMimeType": "리소스의 MIME 타입 결정",
          "returnImageResource": "이미지 리소스와 Content-Type 헤더 반환",
          "notFoundResponse": "404 응답",
          "serverErrorResponse": "500 응답"
        },
        "frontendTitle": "프론트엔드 구현",
        "frontend": {
          "description": "프론트엔드 구현은 드래그 앤 드롭 파일 업로드 및 이미지 미리보기가 있는 사용자 친화적인 경험에 중점을 둡니다.",
          "step1": "사용자가 질문에 쉽게 이미지를 첨부할 수 있는 드래그 앤 드롭 영역을 구현했습니다.",
          "step2": "제출 전에 이미지 미리보기가 표시되어 사용자가 첨부 파일을 확인할 수 있습니다.",
          "step3": "양식은 클라이언트 측(즉각적인 피드백용)과 서버 측(보안용) 모두에서 유효성 검사를 처리합니다.",
          "previewElement": "미리보기 요소 생성",
          "authenticatedUser": "인증된 사용자 정보",
          "successProcessing": "성공 시 처리",
          "registrationError": "등록 중 오류가 발생했습니다."
        },
        "carousel": {
          "qnaList": "그림 1: 검색 및 필터링이 있는 Q&A 목록",
          "qnaWrite": "그림 2: 이미지 업로드 기능이 있는 질문 제출 양식",
          "qnaView": "그림 3: 답변이 있는 질문 상세 보기"
        },
        "comments": {
          "fileUpload.comment2": "QnA 제목이 비어있는 경우 유효성 검사를 수행하고 에러 응답을 반환합니다.",
          "fileUpload.comment3": "QnA 서비스의 register 메서드를 호출하여 QnA 정보와 첨부 파일을 함께 등록합니다.",
          "fileUpload.comment4": "등록 성공 시 저장된 QnaDTO 객체를 포함하여 HTTP 200 OK 응답을 반환합니다.",
          "uploadConfig.comment1": "application.properties 또는 application.yml 파일에서 'org.zerock.upload.path' 속성 값을 주입받습니다.",
          "uploadConfig.comment2": "빈(Bean) 초기화 시(@PostConstruct) 업로드 경로가 존재하는지 확인하고 없으면 생성합니다.",
          "fileStorage.comment1": "게시글 저장 및 파일 처리의 원자성 보장",
          "fileStorage.comment2": "1. Qna 엔티티 생성 및 저장",
          "fileStorage.comment3": "2. 이미지 파일 처리 및 QnaImage 엔티티 생성/연결",
          "fileStorage.comment4": "고유 파일명 생성 (UUID 사용)",
          "fileStorage.comment5": "실제 파일 저장",
          "fileStorage.comment6": "QnaImage 엔티티 생성 및 연관관계 설정",
          "fileStorage.comment7": "연관관계 설정",
          "fileStorage.comment8": "이미지 정보가 추가된 Qna 엔티티 저장",
          "fileStorage.comment9": "최종 저장된 Qna 엔티티를 QnaDTO로 변환하여 반환합니다.",
          "fileAccess.comment1": "특정 이미지 ID에 해당하는 이미지 파일을 조회하기 위한 GET 요청 핸들러입니다.",
          "fileAccess.comment2": "이미지 ID를 기반으로 이미지 리소스를 가져오는 서비스 메서드입니다.",
          "fileAccess.comment3": "QnaImageRepository를 사용하여 이미지 ID로 QnaImage 엔티티를 조회합니다. 없으면 EntityNotFoundException 발생.",
          "fileAccess.comment4": "설정된 업로드 경로와 이미지 파일명을 조합하여 실제 파일 경로(Path) 객체를 생성합니다.",
          "fileAccess.comment5": "파일 경로를 URI로 변환하고 UrlResource 객체를 생성하여 리소스를 표현합니다. 파일이 존재하고 읽기 가능한지 확인합니다.",
          "frontend.comment1": "폼 제출 이벤트 리스너를 등록합니다.",
          "frontend.comment2": "기본 폼 제출 동작(페이지 새로고침)을 막습니다.",
          "frontend.comment3": "파일을 포함한 폼 데이터를 담을 FormData 객체를 생성합니다.",
          "frontend.comment4": "텍스트 입력 필드(제목, 내용) 값을 FormData에 추가합니다.",
          "frontend.comment5": "파일 입력(imageFiles)에서 선택된 모든 파일을 FormData에 추가합니다.",
          "frontend.comment6": "CSRF 토큰과 헤더 이름을 Thymeleaf 변수 또는 JavaScript 변수에서 가져옵니다.",
          "frontend.comment7": "fetch API를 사용하여 '/qna/api/register' 경로로 POST 요청을 보냅니다. FormData와 CSRF 헤더를 포함합니다.",
          "frontend.comment8": "등록 성공 시, 반환된 qno를 사용하여 QnA 상세 보기 페이지로 리디렉션합니다.",
          "frontend.comment9": "파일 선택 시 이미지 미리보기를 업데이트하는 함수입니다.",
          "frontend.comment10": "기존 미리보기 초기화",
          "frontend.comment11": "각 파일에 대해 FileReader를 사용하여 이미지 데이터를 읽고, 미리보기 요소를 생성하여 화면에 추가합니다.",
          "frontend.comment12": "현재 로그인한 사용자 정보 (이 예시에서는 null)."
        }
      },
      "commonComponents": {
        "title": "공통 컴포넌트 및 설정",
        "goal": "목표",
        "description": "코드 재사용성과 유지보수성을 향상시키기 위해 애플리케이션 전반에서 사용할 수 있는 공통 컴포넌트와 설정을 설계하고 구현하였습니다.",
        "implementation": "구현 방식",
        "additionalDescription": "애플리케이션 전체에서 사용할 수 있는 유틸리티 클래스, 커스텀 어노테이션, AOP(관점 지향 프로그래밍) 컴포넌트 및 설정 클래스를 생성하였습니다.",
        "keyFeatures": "주요 기능",
        "keyFeaturesDescription": "공통 컴포넌트는 일관된 오류 처리, 보안 설정, 리소스 관리 등을 제공하여 균일한 사용자 경험과 코드 표준을 보장합니다.",
        "solution": "`application`과 같이 환경별 설정 파일을 분리하고 Spring 프로파일 기능을 활용하여, 각 환경에 맞는 설정을 체계적으로 관리하고 적용할 수 있도록 개선했습니다.",
        "mainComponents": "주요 공통 컴포넌트",
        "webMvcConfig": "WebMvcConfig",
        "webMvcConfig.step1": "리소스 처리, 인터셉터, 뷰 리졸버 등을 포함한 Spring MVC의 동작을 커스터마이징하기 위해 WebMvcConfig를 구현하였습니다.",
        "webMvcConfig.cacheDisable": "캐시 무효화",
        "customSecurityConfig": "CustomSecurityConfig",
        "customSecurityConfig.step1": "애플리케이션을 보호하기 위한 인증, 권한 부여 및 다양한 보안 기능을 제공하는 보안 구성을 생성하였습니다.",
        "webSocketConfig": "WebSocketConfig",
        "webSocketConfig.step1": "실시간 알림 및 채팅과 같은 기능을 위해 클라이언트와 서버 간의 실시간 통신을 가능하게 하는 WebSocketConfig를 구현하였습니다.",
        "uploadConfig": "UploadConfig",
        "uploadConfig.step1": "저장 위치, 파일 크기 제한 및 허용된 파일 유형을 관리하는, 파일 업로드를 위한 구성을 생성하였습니다.",
        "globalExceptionHandler": "GlobalExceptionHandler",
        "globalExceptionHandler.step1": "애플리케이션 전체에서 예외를 포착하는 중앙 집중식 오류 처리 메커니즘을 구현했습니다.",
        "globalExceptionHandler.step2": "각 유형의 예외는 적절하게 처리되어 사용자에게 의미 있는 오류 메시지를 제공합니다.",
        "globalExceptionHandler.step3": "이를 통해 전체 애플리케이션에서 일관된 오류 응답 형식을 보장합니다.",
        "customErrorController": "CustomErrorController",
        "customErrorController.step1": "404(Not Found) 또는 500(Internal Server Error)과 같은 HTTP 오류 상태 코드를 사용자 친화적인 방식으로 처리하는 커스텀 오류 컨트롤러를 생성했습니다.",
        "thymeleaf": "Thymeleaf 구성",
        "thymeleaf.step1": "커스텀 방언 및 프래그먼트 처리를 통해 애플리케이션 전체에서 일관된 UI를 생성하기 위해 템플릿 엔진으로 Thymeleaf를 구성했습니다.",
        "environmentalManagement": "프로젝트 환경(개발, 테스트, 운영 등)이 다양해짐에 따라 각 환경에 맞는 설정을 관리하는 것이 복잡해질 수 있습니다. ",
        "inconsistentUserExperience": "예상치 못한 오류가 발생했을 때, 사용자에게 명확하지 않거나 일관성 없는 오류 메시지를 보여주면 사용자 경험이 저하될 수 있습니다.",
        "configurationManagement": "구성 관리",
        "errorHandling": "오류 처리",
        "concerns": "문제점 및 해결 방안",
        "environmentalProblem": "개발, 테스트, 운영 등 다양한 환경에 따라 설정을 다르게 관리해야 하는 점이 번거로울 수 있었습니다.",
        "environmentalSolution": "`application`과 같이 환경별 설정 파일을 분리하고 Spring 프로파일 기능을 활용하여, 각 환경에 맞는 설정을 체계적으로 관리하고 적용할 수 있도록 개선했습니다.",
        "userExperienceProblem": "예상치 못한 오류가 발생했을 때 사용자에게 혼란을 주거나 통일되지 않은 오류 메시지를 보여줄 경우, 서비스 사용 경험이 저하될 수 있습니다.",
        "userExperienceSolution": "`@RestControllerAdvice`와 `ErrorController`를 도입하여 애플리케이션 전반의 예외를 일관되게 처리하고, 사용자에게 이해하기 쉬운 표준화된 오류 피드백을 제공함으로써 안정적인 사용자 경험을 유지하도록 했습니다."
      },
      "developmentEnvironment": {
        "title": "개발 환경",
        "description": "다음은 WORK OUT 프로젝트를 구축하는 데 사용된 개발 환경 및 도구에 대한 요약입니다.",
        "technology": "기술 스택",
        "springBoot": "Spring Boot",
        "gradle": "Gradle",
        "java": "Java 17",
        "staticResources": "정적 리소스",
        "deploymentConfiguration": "배포 구성",
        "jar": "JAR",
        "properties": "application-*.properties",
        "performanceOptimization": "성능 최적화",
        "springBootDescription": "로 빠른 개발 환경 구축",
        "gradleDescription": "로 의존성 및 빌드 자동화",
        "javaDescription": "기반의 안정적 서버",
        "staticResourcesDescription": "는 `/src/main/resources/static`에서 관리",
        "deploymentConfigurationDescription": "실행 가능한 JAR 파일로 패키징, application-*.properties로 환경별 설정 분리, 성능 최적화 등"
      },
      "futureImprovements": {
        "title": "향후 개선 사항",
        "mobileAppIntegration": "모바일 앱 통합",
        "realTimeNotificationSystem": "실시간 알림 시스템 고도화",
        "aiFunction": "AI 기반 운동 자세 분석",
        "socialLogin": "소셜 로그인 통합",
        "mobileAppIntegrationDescription": "REST API 확장 및 모바일 클라이언트 지원",
        "realTimeNotificationSystemDescription": "WebSocket 기반 알림 고도화",
        "aiFunctionDescription": "운동 자세 분석 및 피드백 기능 추가 검토",
        "socialLoginDescription": "카카오, 구글 등 외부 인증 연동"
      },
      "closing": {
        "title": "7. 맺음말",
        "description": "WORK OUT 프로젝트는 단순한 정보 공유 커뮤니티를 넘어, `WebRTC`와 `WebSocket`을 활용한 실시간 화상 트레이닝, `Spring Boot` 기반의 안정적 시스템, `Spring Security`를 통한 보안 등 다양한 기술을 통합하여 차별화된 경험을 제공하고자 하였습니다. 앞으로도 더 나은 서비스를 제공하기 위해 지속적으로 개선할 예정입니다. 이 프로젝트를 통해 얻은 경험과 노하우는 향후 더 발전된 서비스 개발의 밑거름이 될 것입니다."
      },
      "experience": {
        "title": "WORK OUT을 경험해보세요",
        "preview": "Capu Blog 미리보기"
      },
      "serviceLinks": {
        "title": "서비스 링크",
        "ezpzService": "EZPZ 서비스 바로가기",
        "githubRepository": "GitHub 저장소"
      },
      "errorController": {
        "undefinedStatusCode": "정의되지 않은 상태 코드",
        "notFound": "요청하신 리소스를 찾을 수 없습니다.",
        "internalError": "서버 내부 오류가 발생했습니다.",
        "defaultMessage": "기본 HTTP 상태 메시지"
      }
    },
    "codeComments": {
      "webRtc": {
        "comment1": "WebSocket 연결 시도 및 중복 연결 방지 로직 시작",
        "comment2": "SockJS를 사용하여 WebSocket 엔드포인트('/ws')에 연결합니다.",
        "comment3": "STOMP 클라이언트 디버그 메시지를 비활성화합니다.",
        "comment4": "연결 성공 후, 'join' 시그널을 전송하여 방 참여를 알립니다.",
        "comment5": "연결 실패 시 5초 후 재연결을 시도합니다.",
        "comment6": "STOMP 클라이언트를 통해 시그널링 메시지를 전송하는 함수입니다.",
        "comment7": "WebSocket이 연결되지 않은 경우, 메시지 전송 실패를 로그에 기록합니다.",
        "comment8": "수신된 시그널링 메시지를 처리하는 함수입니다.",
        "comment9": "'join' 메시지: 새로운 참가자가 방에 입장했음을 나타냅니다.",
        "comment10": "새 참가자를 위한 PeerConnection을 생성하고, Offer를 생성하도록 지시합니다.",
        "comment11": "'offer' 메시지: 다른 피어로부터 SDP Offer를 수신했습니다.",
        "comment12": "Offer 수신 및 처리 중 오류 발생 시 로그를 기록합니다.",
        "comment13": "'answer' 메시지: 다른 피어로부터 SDP Answer를 수신했습니다.",
        "comment14": "Answer 수신 및 처리 중 오류 발생 시 로그를 기록합니다.",
        "comment15": "'candidate' 메시지: 다른 피어로부터 ICE Candidate를 수신했습니다.",
        "comment16": "ICE Candidate 추가 중 오류 발생 시 로그를 기록합니다.",
        "comment17": "지정된 remoteId에 대한 RTCPeerConnection 객체를 생성하는 함수입니다.",
        "comment18": "새 PeerConnection 생성 로그를 기록합니다.",
        "comment19": "Offer를 생성해야 하는지 여부를 로그에 표시합니다.",
        "comment20": "기존 PeerConnection이 있다면 종료합니다.",
        "comment21": "로컬 미디어 스트림이 있다면, 각 트랙을 새 PeerConnection에 추가합니다.",
        "comment22": "로컬 스트림 트랙 추가 로그를 기록합니다.",
        "comment23": "ICE Candidate 생성 시 호출될 콜백 함수를 설정합니다. 생성된 Candidate를 상대방에게 전송합니다.",
        "comment24": "원격 피어로부터 미디어 트랙을 수신했을 때 호출될 콜백 함수를 설정합니다.",
        "comment25": "원격 트랙 수신 로그를 기록합니다.",
        "comment26": "원격 비디오를 표시할 HTML 요소가 없는 경우 처리 로직 (주석 처리됨).",
        "comment27": "원격 비디오 스트림 설정 로그를 기록합니다.",
        "comment28": "ICE 연결 상태 변경 시 로그를 기록하는 콜백 함수를 설정합니다.",
        "comment29": "Offer를 생성해야 하는 경우, Offer를 생성하고 Local Description으로 설정한 후 상대방에게 전송합니다.",
        "comment30": "Offer 생성 및 전송 중 오류 발생 시 로그를 기록합니다.",
        "comment31": "DOM 로딩 완료 후 초기화 로직입니다.",
        "initEvent": "페이지 로딩 시 roomId가 있으면 WebSocket 연결을 시작합니다."
      },
      "boardSearch": {
        "qBoardComment": "QBoard 객체를 생성하여 타입 세이프한 쿼리 작성을 준비합니다.",
        "queryComment": "JPQLQuery 객체를 생성하고 기본 FROM 절을 설정합니다.",
        "basicCondition": "키워드가 존재하고 비어있지 않은 경우, 제목(title)에 키워드를 포함하는 조건을 추가합니다.",
        "dynamicCondition": "기본 조건으로 게시글 번호(bno)가 0보다 큰 조건을 추가합니다. (예시: 모든 게시글 대상)"
      },
      "booleanBuilder": {
        "comment1": "동적 조건을 조합하기 위한 BooleanBuilder 객체를 생성합니다.",
        "comment2": "검색 타입 문자열(예: 'tcw')을 각 문자로 분리합니다.",
        "comment3": "검색 타입과 키워드가 유효한 경우, OR 조건을 묶기 위한 내부 BooleanBuilder를 생성합니다.",
        "comment4": "'t': 제목(title)에 키워드를 포함하는 조건을 OR로 추가합니다.",
        "comment5": "'c': 내용(content)에 키워드를 포함하는 조건을 OR로 추가합니다.",
        "comment6": "'w': 작성자 이름(writer.userName)에 키워드를 포함하는 조건을 OR로 추가합니다.",
        "comment7": "내부적으로 OR 조합된 조건들을 최종 BooleanBuilder에 AND로 결합합니다.",
        "comment8": "검색 타입/키워드가 없는 경우 이 블록은 건너뜁니다.",
        "comment9": "최종적으로 구성된 BooleanBuilder 조건을 JPQLQuery의 WHERE 절에 적용합니다."
      },
      "security": {
        "comment1": "세션 만료 시 리디렉션될 URL을 '/member/login?expired'로 설정합니다.",
        "comment2": "CSRF 보호를 특정 경로들('/member/login', '/member/join' 등)에 대해 비활성화합니다.",
        "comment3": "회원 정보 수정을 위한 서비스 메서드입니다."
      },
      "fileUpload": {
        "comment2": "QnA 제목이 비어있는 경우 유효성 검사를 수행하고 에러 응답을 반환합니다.",
        "comment3": "QnA 서비스의 register 메서드를 호출하여 QnA 정보와 첨부 파일을 함께 등록합니다.",
        "comment4": "등록 성공 시 저장된 QnaDTO 객체를 포함하여 HTTP 200 OK 응답을 반환합니다."
      },
      "uploadConfig": {
        "comment1": "application.properties 또는 application.yml 파일에서 'org.zerock.upload.path' 속성 값을 주입받습니다.",
        "comment2": "빈(Bean) 초기화 시(@PostConstruct) 업로드 경로가 존재하는지 확인하고 없으면 생성합니다."
      },
      "fileStorage": {
        "comment1": "게시글 저장 및 파일 처리의 원자성 보장",
        "comment2": "1. Qna 엔티티 생성 및 저장",
        "comment3": "2. 이미지 파일 처리 및 QnaImage 엔티티 생성/연결",
        "comment4": "고유 파일명 생성 (UUID 사용)",
        "comment5": "실제 파일 저장",
        "comment6": "QnaImage 엔티티 생성 및 연관관계 설정",
        "comment7": "연관관계 설정",
        "comment8": "이미지 정보가 추가된 Qna 엔티티 저장",
        "comment9": "최종 저장된 Qna 엔티티를 QnaDTO로 변환하여 반환합니다."
      },
      "fileAccess": {
        "comment1": "특정 이미지 ID에 해당하는 이미지 파일을 조회하기 위한 GET 요청 핸들러입니다.",
        "comment2": "이미지 ID를 기반으로 이미지 리소스를 가져오는 서비스 메서드입니다.",
        "comment3": "QnaImageRepository를 사용하여 이미지 ID로 QnaImage 엔티티를 조회합니다. 없으면 EntityNotFoundException 발생.",
        "comment4": "설정된 업로드 경로와 이미지 파일명을 조합하여 실제 파일 경로(Path) 객체를 생성합니다.",
        "comment5": "파일 경로를 URI로 변환하고 UrlResource 객체를 생성하여 리소스를 표현합니다. 파일이 존재하고 읽기 가능한지 확인합니다.",
        "comment6": "특정 이미지 ID에 해당하는 이미지 파일을 조회하기 위한 GET 요청 핸들러입니다.",
        "comment7": "이미지 ID를 기반으로 이미지 리소스를 가져오는 서비스 메서드입니다.",
        "comment8": "QnaImageRepository를 사용하여 이미지 ID로 QnaImage 엔티티를 조회합니다. 없으면 EntityNotFoundException 발생.",
        "comment9": "설정된 업로드 경로와 이미지 파일명을 조합하여 실제 파일 경로(Path) 객체를 생성합니다.",
        "comment10": "파일 경로를 URI로 변환하고 UrlResource 객체를 생성하여 리소스를 표현합니다. 파일이 존재하고 읽기 가능한지 확인합니다.",
        "comment11": "특정 이미지 ID에 해당하는 이미지 파일을 조회하기 위한 GET 요청 핸들러입니다.",
        "comment12": "이미지 ID를 기반으로 이미지 리소스를 가져오는 서비스 메서드입니다.",
        "comment13": "QnaImageRepository를 사용하여 이미지 ID로 QnaImage 엔티티를 조회합니다. 없으면 EntityNotFoundException 발생.",
        "comment14": "설정된 업로드 경로와 이미지 파일명을 조합하여 실제 파일 경로(Path) 객체를 생성합니다.",
        "comment15": "파일 경로를 URI로 변환하고 UrlResource 객체를 생성하여 리소스를 표현합니다. 파일이 존재하고 읽기 가능한지 확인합니다.",
        "comment16": "특정 이미지 ID에 해당하는 이미지 파일을 조회하기 위한 GET 요청 핸들러입니다.",
        "comment17": "이미지 ID를 기반으로 이미지 리소스를 가져오는 서비스 메서드입니다.",
        "comment18": "QnaImageRepository를 사용하여 이미지 ID로 QnaImage 엔티티를 조회합니다. 없으면 EntityNotFoundException 발생.",
        "comment19": "설정된 업로드 경로와 이미지 파일명을 조합하여 실제 파일 경로(Path) 객체를 생성합니다.",
        "comment20": "파일 경로를 URI로 변환하고 UrlResource 객체를 생성하여 리소스를 표현합니다. 파일이 존재하고 읽기 가능한지 확인합니다."
      },
      "frontend": {
        "comment1": "폼 제출 이벤트 리스너를 등록합니다.",
        "comment2": "기본 폼 제출 동작(페이지 새로고침)을 막습니다.",
        "comment3": "파일을 포함한 폼 데이터를 담을 FormData 객체를 생성합니다.",
        "comment4": "텍스트 입력 필드(제목, 내용) 값을 FormData에 추가합니다.",
        "comment5": "파일 입력(imageFiles)에서 선택된 모든 파일을 FormData에 추가합니다.",
        "comment6": "CSRF 토큰과 헤더 이름을 Thymeleaf 변수 또는 JavaScript 변수에서 가져옵니다.",
        "comment7": "fetch API를 사용하여 '/qna/api/register' 경로로 POST 요청을 보냅니다. FormData와 CSRF 헤더를 포함합니다.",
        "comment8": "등록 성공 시, 반환된 qno를 사용하여 QnA 상세 보기 페이지로 리디렉션합니다.",
        "comment9": "파일 선택 시 이미지 미리보기를 업데이트하는 함수입니다.",
        "comment10": "기존 미리보기 초기화",
        "comment11": "각 파일에 대해 FileReader를 사용하여 이미지 데이터를 읽고, 미리보기 요소를 생성하여 화면에 추가합니다.",
        "comment12": "현재 로그인한 사용자 정보 (이 예시에서는 null)."
      },
      "webMvcConfig": {
         "cacheDisable": "파비콘 캐시를 비활성화합니다. (개발 중 변경사항 즉시 반영 용도)"
      },
      "dataModeling": {
        "otherCommonFields": "생성일시와 수정일시 외에도 필요에 따라 삭제 여부, 상태 코드 등 다른 공통 필드를 추가할 수 있습니다.",
        "otherFields": "엔티티 간 관계나 핵심 속성 외에도 태그, 카테고리, 좋아요 등 비즈니스 요구사항에 따라 필요한 필드를 추가할 수 있습니다."
      },
      "memberManagement": {
        "enableMethodSecurity": "최신 버전에서는 @EnableMethodSecurity 사용",
        "pathAccessControl": "필요시 경로별 접근 제어 추가",
        "exceptionHandlers": "필요시 접근 거부/인증 실패 핸들러 추가"
      },
      "errorController": {
        "undefinedStatusCode": "정의되지 않은 상태 코드",
        "notFound": "요청하신 리소스를 찾을 수 없습니다.",
        "internalError": "서버 내부 오류가 발생했습니다.",
        "defaultMessage": "기본 HTTP 상태 메시지"
      }
    }
  }
} 